"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const quicktype_core_1 = require("quicktype-core");
const Strings_1 = require("quicktype-core/dist/support/Strings");
const cli_1 = require("../lib/cli");
const naming_1 = require("../lib/naming");
const package_json_1 = require("../../package.json");
const fs = require("fs");
const util = require("util");
const lodash_1 = require("lodash");
const rules_1 = require("../lib/rules");
const writeFile = util.promisify(fs.writeFile);
exports.command = 'gen-ios';
exports.desc = 'Generate a strongly typed analytics-ios client';
exports.builder = Object.assign({}, cli_1.builder, { trackingPlan: {
        type: 'string',
        required: true,
        description: 'Tracking Plan name to use for generated classes'
    }, language: {
        type: 'string',
        required: false,
        default: 'objectivec',
        choices: ['objectivec'],
        description: 'Which iOS language bindings to output'
    }, classPrefix: {
        type: 'string',
        required: false,
        default: 'SEG',
        description: 'Prefix to use for generated class names'
    } });
class AnalyticsObjectiveCTargetLanguage extends quicktype_core_1.ObjectiveCTargetLanguage {
    constructor(trackingPlan, classPrefix) {
        super();
        this.trackingPlan = trackingPlan;
        this.classPrefix = classPrefix;
    }
    makeRenderer(renderContext, _) {
        return new AnalyticsObjectiveCWrapperRenderer(this, renderContext, {
            extraComments: false,
            justTypes: false,
            marshallingFunctions: false,
            classPrefix: this.classPrefix,
            features: { interface: true, implementation: true },
            trackingPlan: this.trackingPlan
        });
    }
    get supportsOptionalClassProperties() {
        return true;
    }
}
class AnalyticsObjectiveCWrapperRenderer extends quicktype_core_1.ObjectiveCRenderer {
    constructor(targetLanguage, renderContext, options) {
        super(targetLanguage, renderContext, options);
        this.options = options;
    }
    emitImports(globalImports, localImports) {
        lodash_1.map(globalImports, i => {
            this.emitLine(`#import <${i}>`);
        });
        lodash_1.map(localImports, i => {
            this.emitLine(`#import "${i}"`);
        });
    }
    emitClassDeclaration(className) {
        this.emitLine(['@class ', className, ';']);
    }
    emitClassDeclarations(fileName) {
        this.emitMark('Class Declarations');
        this.ensureBlankLine();
        this.forEachNamedType('none', (_, className) => {
            this.emitClassDeclaration(className);
            this.emitClassDeclaration([className, 'Builder']);
        }, (_, enumName) => this.emitLine('@class ', enumName, ';'), () => null);
        this.emitClassDeclaration(fileName);
    }
    emitInterfaces() {
        this.forEachNamedType('leading-and-interposing', (t, name) => {
            this.emitInterface(name, { extends: 'NSObject' }, () => {
                this.emitClassProperties(t);
            });
            this.ensureBlankLine();
            this.emitLine(['typedef void (^ ', name, 'BuilderBlock)(', name, 'Builder *);']);
            this.emitInterface([name, 'Builder'], { extends: 'NSObject' }, () => {
                this.emitLine(['+ (', name, ' *)initWithBlock:(', name, 'BuilderBlock)block;']);
                this.emitClassProperties(t);
            });
        }, () => null, () => null);
    }
    emitAnalyticsInterface(fileName) {
        this.emitInterface(fileName, { extends: 'NSObject' }, () => {
            this.emitLine('- (instancetype)initWithAnalytics:(SEGAnalytics *)analytics;');
            this.ensureBlankLine();
            this.forEachTopLevel('leading-and-interposing', (t, name) => {
                if (t instanceof quicktype_core_1.ObjectType) {
                    this.emitDescription(this.descriptionForType(t));
                    const hasProperties = t.getProperties().size > 0;
                    this.emitLine([
                        '- (void)',
                        this.variableNameForTopLevel(name),
                        ...(hasProperties ? [':(', name, ' *)props;'] : [';'])
                    ]);
                    this.emitLine([
                        '- (void)',
                        this.variableNameForTopLevel(name),
                        ':',
                        ...(hasProperties ? ['(', name, ' *)props withOptions:'] : []),
                        '(NSDictionary<NSString *, id> *_Nullable)options;'
                    ]);
                }
            });
        });
    }
    emitInterface(className, options, emitContents) {
        const optionalExtension = options.extends ? ` : ${options.extends}` : '';
        const optionalCategory = options.category !== undefined ? ` (${options.category})` : '';
        this.emitLine(['@interface ', className, optionalExtension, optionalCategory]);
        emitContents();
        this.emitLine('@end');
    }
    emitImplementation(className, emitContents) {
        this.emitLine(['@implementation ', className]);
        emitContents();
        this.emitLine('@end');
    }
    emitAutogeneratedFileWarning() {
        this.emitCommentLines(['This code is auto-generated by Segment Typewriter. Do not edit.']);
    }
    emitInterfaceFile(fileName) {
        this.startFile(fileName, 'h');
        this.emitAutogeneratedFileWarning();
        this.emitLine(['#ifndef ', fileName, '_h']);
        this.emitLine(['#define ', fileName, '_h']);
        this.ensureBlankLine();
        this.emitImports(['Foundation/Foundation.h', 'Analytics/SEGAnalytics.h'], []);
        this.ensureBlankLine();
        this.emitClassDeclarations(fileName);
        this.ensureBlankLine();
        this.emitLine('NS_ASSUME_NONNULL_BEGIN');
        this.ensureBlankLine();
        this.emitInterfaces();
        this.ensureBlankLine();
        this.emitAnalyticsInterface(fileName);
        this.ensureBlankLine();
        this.emitLine('NS_ASSUME_NONNULL_END');
        this.ensureBlankLine();
        this.emitLine(['#endif /* ', fileName, '_h */']);
        this.ensureBlankLine();
        this.finishFile();
    }
    emitTypewriterContextFields() {
        this.emitBlock('static NSDictionary<NSString *, id> *_Nullable addTypewriterContextFields(NSDictionary<NSString *, id> *_Nullable options)', () => {
            this.emitLine('options = options ?: @{};');
            this.emitLine('NSDictionary<NSString *, id> *customContext = options[@"context"] ?: @{};');
            this.emitLine('NSDictionary<NSString *, id> *typewriterContext = @{');
            this.emitLine('                                                    @"typewriter": @{');
            this.emitLine('                                                            @"name": @"', exports.command, '",');
            this.emitLine('                                                            @"version": @"', package_json_1.version, '"');
            this.emitLine('                                                            }');
            this.emitLine('                                                    };');
            this.emitLine('NSMutableDictionary *context = [NSMutableDictionary dictionaryWithCapacity:customContext.count + typewriterContext.count];');
            this.emitLine('[context addEntriesFromDictionary:customContext];');
            this.emitLine('[context addEntriesFromDictionary:typewriterContext];');
            this.emitLine('');
            this.emitLine('NSMutableDictionary *newOptions = [NSMutableDictionary dictionaryWithCapacity:options.count + 1];');
            this.emitLine('[newOptions addEntriesFromDictionary:options];');
            this.emitLine('[newOptions addEntriesFromDictionary:@{');
            this.emitLine('                                       @"context": context');
            this.emitLine('                                       }];');
            this.emitLine('return newOptions;');
        });
    }
    emitImplementationHelpers() {
        this.emitLine(`#define Î»(decl, expr) (^(decl) { return (expr); })`);
        this.ensureBlankLine();
        this.emitBlock('static id NSNullify(id _Nullable x)', () => this.emitLine('return (x == nil || x == NSNull.null) ? NSNull.null : x;'));
        this.ensureBlankLine();
        this.emitTypewriterContextFields();
    }
    emitDictionaryPruner() {
        this.emitBlock('static id prune(NSDictionary *dict)', () => {
            this.emitLine('NSMutableDictionary *prunedDict = [dict mutableCopy];');
            this.emitLine('NSArray *keysForNullValues = [dict allKeysForObject:[NSNull null]];');
            this.emitLine('[prunedDict removeObjectsForKeys:keysForNullValues];');
            this.emitLine('return prunedDict;');
        });
    }
    emitPrivateInterfaces() {
        this.forEachNamedType('leading-and-interposing', (_, name) => {
            this.emitInterface(name, { category: 'JSONConversion' }, () => {
                this.emitLine('- (NSDictionary *)JSONDictionary;');
            });
        }, () => null, () => null);
    }
    emitPrivateAnalyticsInterface(name) {
        this.emitInterface(name, { category: '' }, () => {
            this.emitLine('@property (nonatomic, nullable) SEGAnalytics *analytics;');
        });
    }
    emitPropertiesGetter(c) {
        this.emitMethod('+ (NSDictionary<NSString *, NSString *> *)properties', () => {
            this.emitLine('static NSDictionary<NSString *, NSString *> *properties;');
            this.emitLine('return properties = properties ? properties : @{');
            this.indent(() => {
                this.forEachClassProperty(c, 'none', (name, jsonName) => this.emitLine(`@"${Strings_1.stringEscape(jsonName)}": @"`, name, `",`));
            });
            this.emitLine('};');
        });
    }
    emitSetter(name) {
        this.emitMethod('- (void)setValue:(nullable id)value forKey:(NSString *)key', () => {
            this.emitLine(['id resolved = ', name, '.properties[key];']);
            this.emitLine('if (resolved) [super setValue:value forKey:resolved];');
        });
    }
    emitBuildMethod(c, className) {
        this.emitMethod(['+ (', className, ' *)initWithBlock:(', className, 'BuilderBlock)block'], () => {
            this.emitLine('NSParameterAssert(block);');
            this.ensureBlankLine();
            this.emitLine([className, 'Builder *builder = [[', className, 'Builder alloc] init];']);
            this.emitLine('block(builder);');
            this.ensureBlankLine();
            this.forEachClassProperty(c, 'none', (name, _, prop) => {
                if (!prop.isOptional) {
                    this.emitBlock(['if (builder.', name, ' == NULL)'], () => {
                        this.emitLine([
                            '@throw [NSException exceptionWithName:@"Missing Required Property" reason:@"',
                            className,
                            ' is missing a required property: ',
                            name,
                            '" userInfo:NULL];'
                        ]);
                    });
                    this.ensureBlankLine();
                }
            });
            const variableName = this.variableNameForTopLevel(className);
            this.emitLine([className, ' *', variableName, ' = [[', className, ' alloc] init];']);
            this.forEachClassProperty(c, 'none', name => {
                this.emitLine([variableName, '.', name, ' = builder.', name, ';']);
            });
            this.emitLine(['return ', variableName, ';']);
        });
    }
    emitImplementations() {
        this.forEachNamedType('leading-and-interposing', (c, name) => {
            this.emitImplementation(name, () => {
                this.emitPropertiesGetter(c);
                this.ensureBlankLine();
                if (this.hasIrregularProperties(c)) {
                    this.emitSetter(name);
                    this.ensureBlankLine();
                }
                this.emitJSONDictionary(c, name);
            });
            this.ensureBlankLine();
            this.emitImplementation([name, 'Builder'], () => {
                this.emitBuildMethod(c, name);
            });
        }, () => null, () => null);
    }
    emitAnalyticsWrapperMethod(name, hasProperties, withOptions) {
        const camelCaseName = this.variableNameForTopLevel(name);
        this.emitMethod([
            '- (void)',
            camelCaseName,
            hasProperties || withOptions ? ':' : '',
            ...(hasProperties ? ['(', name, ' *)props'] : []),
            hasProperties && withOptions ? ' ' : '',
            ...(withOptions
                ? [
                    hasProperties ? 'withOptions:' : '',
                    '(NSDictionary<NSString *, id> *_Nullable)options'
                ]
                : [])
        ], () => {
            if (withOptions) {
                this.emitLine([
                    '[self.analytics track:@"',
                    naming_1.getRawName(name),
                    '" properties:',
                    hasProperties ? '[props JSONDictionary]' : '@{}',
                    withOptions ? ' options:addTypewriterContextFields(options)' : '',
                    '];'
                ]);
            }
            else {
                this.emitLine([
                    '[self ',
                    camelCaseName,
                    ':',
                    hasProperties ? 'props withOptions:' : '',
                    '@{}];'
                ]);
            }
        });
    }
    emitAnalyticsWrapperImplementation(fileName) {
        this.emitImplementation(fileName, () => {
            this.emitMethod('- (instancetype)initWithAnalytics:(SEGAnalytics *)analytics', () => {
                this.emitLine('self = [super init];');
                this.emitBlock('if (self)', () => {
                    this.emitLine('_analytics = analytics;');
                });
                this.emitLine('return self;');
            });
            this.ensureBlankLine();
            this.forEachTopLevel('leading-and-interposing', (t, className) => {
                if (t instanceof quicktype_core_1.ObjectType) {
                    const hasProperties = t.getProperties().size > 0;
                    this.emitAnalyticsWrapperMethod(className, hasProperties, false);
                    this.emitAnalyticsWrapperMethod(className, hasProperties, true);
                }
            });
        });
    }
    emitImplementationFile(fileName) {
        this.startFile(fileName, 'm');
        this.emitAutogeneratedFileWarning();
        this.emitImports([], [`${fileName}.h`]);
        this.ensureBlankLine();
        this.emitMark('Helper functions');
        this.ensureBlankLine();
        this.emitImplementationHelpers();
        this.ensureBlankLine();
        this.emitLine('NS_ASSUME_NONNULL_BEGIN');
        this.ensureBlankLine();
        this.emitDictionaryPruner();
        this.ensureBlankLine();
        this.emitMapFunction();
        this.ensureBlankLine();
        this.emitMark('Private interfaces');
        this.ensureBlankLine();
        this.emitPrivateInterfaces();
        this.ensureBlankLine();
        this.emitPrivateAnalyticsInterface(fileName);
        this.ensureBlankLine();
        this.emitMark('JSON Serialization');
        this.ensureBlankLine();
        this.emitImplementations();
        this.ensureBlankLine();
        this.emitAnalyticsWrapperImplementation(fileName);
        this.ensureBlankLine();
        this.emitLine('NS_ASSUME_NONNULL_END');
        this.ensureBlankLine();
        this.finishFile();
    }
    emitSourceStructure(_) {
        const fileName = `${this.options.classPrefix}${lodash_1.upperFirst(lodash_1.camelCase(this.options.trackingPlan || ''))}Analytics`;
        this.emitInterfaceFile(fileName);
        this.emitImplementationFile(fileName);
    }
    emitClassProperties(t) {
        this.emitPropertyTable(t, (name, _, property) => {
            const attributes = ['nonatomic'];
            if (property.isOptional) {
                attributes.push('nullable');
            }
            attributes.push(this.memoryAttribute(property.type, property.type.isNullable));
            return [
                ['@property ', ['(', attributes.join(', '), ')'], ' '],
                [this.pointerAwareTypeName(property.type), name, ';']
            ];
        });
    }
    emitJSONDictionary(c, className) {
        this.emitMethod('- (NSDictionary *)JSONDictionary', () => {
            if (!this.hasIrregularProperties(c) && !this.hasUnsafeProperties(c)) {
                this.emitLine('return [self dictionaryWithValuesForKeys:', className, '.properties.allValues];');
                return;
            }
            this.emitLine('id dict = [[self dictionaryWithValuesForKeys:', className, '.properties.allValues] mutableCopy];');
            this.ensureBlankLine();
            if (this.hasIrregularProperties(c)) {
                this.emitBlock(['for (id jsonName in ', className, '.properties)'], () => {
                    this.emitLine(`id propertyName = `, className, `.properties[jsonName];`);
                    this.emitBlock(`if (![jsonName isEqualToString:propertyName])`, () => {
                        this.emitLine(`dict[jsonName] = dict[propertyName];`);
                        this.emitLine(`[dict removeObjectForKey:propertyName];`);
                    });
                });
            }
            if (this.hasUnsafeProperties(c)) {
                this.ensureBlankLine();
                this.emitLine('[dict addEntriesFromDictionary:@{');
                this.indent(() => {
                    this.forEachClassProperty(c, 'none', (propertyName, jsonKey, property) => {
                        if (!this.implicitlyConvertsToJSON(property.type)) {
                            const key = Strings_1.stringEscape(jsonKey);
                            const name = ['_', propertyName];
                            this.emitLine('@"', key, '": ', this.toDynamicExpression(property.type, name), ',');
                        }
                    });
                });
                this.emitLine('}];');
            }
            this.ensureBlankLine();
            // NOTE: modifying original JSONDictionary method via prune() here.
            this.emitLine('return prune(dict);');
        });
    }
    /**
     * Always used the boxed types, because of a potential upstream bu with nullable values
     * in QuickType. We need to use a boxed type if we make attach the `nullable` property modifier.
     */
    objcType(t, _) {
        return super.objcType(t, true);
    }
    /**
     * Override memoryAttribute in order to replace assign with copy for numeric types.
     *
     * Defer to QuickType for all other types.
     */
    memoryAttribute(t, isNullable) {
        return quicktype_core_1.matchType(t, anyType => super.memoryAttribute(t, isNullable), nullType => super.memoryAttribute(t, isNullable), boolType => super.memoryAttribute(t, isNullable), integerType => (isNullable ? 'strong' : 'copy'), doubleType => (isNullable ? 'strong' : 'copy'), stringType => super.memoryAttribute(t, isNullable), arrayType => super.memoryAttribute(t, isNullable), classType => super.memoryAttribute(t, isNullable), mapType => super.memoryAttribute(t, isNullable), enumType => super.memoryAttribute(t, isNullable), unionType => super.memoryAttribute(t, isNullable));
    }
}
function genObjC(events, { trackingPlan, classPrefix }) {
    return __awaiter(this, void 0, void 0, function* () {
        return quicktype_core_1.quicktypeMultiFile({
            lang: new AnalyticsObjectiveCTargetLanguage(trackingPlan, classPrefix),
            inputData: rules_1.processEventsForQuickType(events)
        });
    });
}
exports.genObjC = genObjC;
exports.handler = cli_1.getTypedTrackHandler((params, { events }) => __awaiter(this, void 0, void 0, function* () {
    let files;
    if (params.language === 'objectivec') {
        files = yield genObjC(events, params);
    }
    else {
        throw new Error(`Invalid language: ${params.language}`);
    }
    return Promise.all(lodash_1.map([...files.keys()], (fileName) => {
        return writeFile(`${params.outputPath}/${fileName}`, files.get(fileName).lines.join('\n'));
    }));
}));
//# sourceMappingURL=gen-ios.js.map