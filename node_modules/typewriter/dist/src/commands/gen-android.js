"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const quicktype_core_1 = require("quicktype-core");
const Source_1 = require("quicktype-core/dist/Source");
const cli_1 = require("../lib/cli");
const fs = require("fs");
const util = require("util");
const lodash_1 = require("lodash");
const Acronyms_1 = require("quicktype-core/dist/support/Acronyms");
const naming_1 = require("../lib/naming");
const rules_1 = require("../lib/rules");
const writeFile = util.promisify(fs.writeFile);
exports.command = 'gen-android';
exports.desc = 'Generate a strongly typed analytics-android client';
exports.builder = Object.assign({}, cli_1.builder, { package: {
        type: 'string',
        required: true,
        description: 'Used as the package name in generated classes'
    }, trackingPlan: {
        type: 'string',
        required: false,
        description: 'Used to name the exported Analytics class'
    }, language: {
        type: 'string',
        required: false,
        default: 'java',
        choices: ['java'],
        description: 'Which Android language bindings to generate'
    } });
class AnalyticsJavaTargetLanguage extends quicktype_core_1.JavaTargetLanguage {
    constructor(packageName, trackingPlan) {
        super();
        this.packageName = packageName;
        this.trackingPlan = trackingPlan;
    }
    makeRenderer(renderContext, _) {
        return new AnalyticsJavaWrapperRenderer(this, renderContext, {
            justTypes: true,
            packageName: this.packageName,
            trackingPlan: this.trackingPlan,
            acronymStyle: Acronyms_1.AcronymStyleOptions.Pascal,
            useList: true
        });
    }
    get defaultIndentation() {
        return '    ';
    }
    get supportsOptionalClassProperties() {
        return true;
    }
}
class AnalyticsJavaWrapperRenderer extends quicktype_core_1.JavaRenderer {
    constructor(targetLanguage, renderContext, options) {
        super(targetLanguage, renderContext, options);
        this.options = options;
    }
    emitAutogeneratedFileWarning() {
        this.emitCommentLines(['This code is auto-generated by Segment Typewriter. Do not edit.']);
    }
    emitPackageAndImports(imports) {
        this.emitAutogeneratedFileWarning();
        super.emitPackageAndImports(imports);
    }
    emitBuilderSetters(c, className) {
        this.forEachClassProperty(c, 'leading-and-interposing', (name, jsonName, p) => {
            this.emitDescriptionBlock([
                ...(this.descriptionForClassProperty(c, jsonName) || []),
                p.isOptional
                    ? [
                        'This property is optional and not required to generate a valid ',
                        className,
                        ' object'
                    ]
                    : ['This property is required to generate a valid ', className, ' object']
            ]);
            const type = this.javaType(true, p.type);
            this.emitBlock(['public Builder ', name, '(final @NonNull ', type, ' ', name, ')'], () => {
                // We need to convert 'List<T>' -> `List<Properties>` so that they will be serialized
                // as objects rather than just toString-ed (aka "com.segment.generated.Product@ab42ba").
                //
                // TODO: there may be a more elegant way to do this, s.t. T satisfies Properties and
                // therefore does not need to be type-cast. Doing so may unlock a more elegant way to
                // support List<List<...>> which won't currently work but are extremely rare in practice.
                if (p.type instanceof quicktype_core_1.ArrayType && type !== 'List<Properties>') {
                    const innerType = this.javaType(false, p.type.items, true);
                    this.emitLine(['List<Properties> p = new ArrayList<>();']);
                    this.emitBlock(['for (', innerType, ' elem : ', name, ')'], () => {
                        this.emitLine(['p.add(elem.toProperties());']);
                    });
                    this.emitLine(['properties.putValue("', jsonName, '", p);']);
                }
                else {
                    this.emitLine(['properties.putValue("', jsonName, '", ', name, ');']);
                }
                this.emitLine('return this;');
            });
        });
    }
    emitRuntimeValidation(c, className) {
        this.forEachClassProperty(c, 'none', (name, jsonName, p) => {
            if (!p.isOptional) {
                this.emitBlock(['if (properties.get("', jsonName, '") == null)'], () => {
                    this.emitLine([
                        'throw new IllegalArgumentException("',
                        className,
                        ' missing required property: ',
                        name,
                        '");'
                    ]);
                });
                this.ensureBlankLine();
            }
        });
    }
    emitClassBuilderDefinition(c, className) {
        this.emitDescriptionBlock([['Builder for {@link ', className, '}']]);
        this.emitBlock(['public static class Builder'], () => {
            this.emitLine('private Properties properties;');
            this.ensureBlankLine();
            this.emitDescriptionBlock([['Builder for {@link ', className, '}']]);
            this.emitBlock('public Builder()', () => {
                this.emitLine('properties = new Properties();');
            });
            this.ensureBlankLine();
            this.emitBuilderSetters(c, className);
            this.ensureBlankLine();
            const requiredProperties = [];
            this.forEachClassProperty(c, 'none', (name, __, p) => {
                if (!p.isOptional) {
                    requiredProperties.push([' - ', name]);
                }
            });
            if (requiredProperties.length > 0) {
                requiredProperties.unshift('Performs runtime validation on the following required properties:');
            }
            this.emitDescriptionBlock([
                ['Build an instance of {@link ', className, '}'],
                ...requiredProperties
            ]);
            this.emitBlock(['public ', className, ' build()'], () => {
                this.emitRuntimeValidation(c, className);
                this.emitLine(['return new ', className, '(properties);']);
            });
        });
    }
    emitPropertiesGetterSetter(className) {
        this.emitLine('private Properties properties;');
        this.ensureBlankLine();
        this.emitBlock(['private ', className, '(Properties properties)'], () => {
            this.emitLine('this.properties = properties;');
        });
        this.ensureBlankLine();
        this.emitBlock(['protected Properties toProperties()'], () => {
            this.emitLine('return properties;');
        });
    }
    emitClassDefinition(c, className) {
        this.emitFileHeader(className, [
            'com.segment.analytics.Properties',
            'androidx.annotation.NonNull'
        ]);
        // TODO: Emit class description, once we support top-level event descriptions in JSON Schema
        // this.emitDescription(this.descriptionForType(c));
        this.emitClassAttributes(c, className);
        this.emitBlock(['public final class ', className], () => {
            this.emitPropertiesGetterSetter(className);
            this.ensureBlankLine();
            this.emitClassBuilderDefinition(c, className);
        });
        this.finishFile();
    }
    /**
     * Note: we override javaType in order to handle the special case of converting a
     * `List<Object>` -> `List<Properties>`. We need this because Properties will serialize a List<Object>
     * using the toString method on each Object, so it prevents users from supplying nested objects.
     * By forcing users to use Properties, we force them to serialize subproperties as Strings.
     *
     * This also handles Objects that appear as properties, or recursively as List<List<...<Object>...>>.
     */
    javaType(reference, t, withIssues = false) {
        if (t instanceof quicktype_core_1.ArrayType) {
            const javaType = this.javaType(false, t.items, withIssues);
            if (javaType === 'Object') {
                return 'List<Properties>';
            }
        }
        return super.javaType(reference, t, withIssues);
    }
    emitAnalyticsEventWrapper(name, hasProperties, withOptions) {
        // TODO: Emit a function description, once we support top-level event descriptions in JSON Schema
        const description = [
            ['@see <a href="https://segment.com/docs/spec/track/">Track Documentation</a>']
        ];
        if (hasProperties) {
            description.unshift([
                '@param props {@link ',
                name,
                '} to add extra information to this call.'
            ]);
        }
        this.emitDescriptionBlock(description);
        const camelCaseName = Source_1.modifySource(lodash_1.camelCase, name);
        this.emitBlock([
            'public void ',
            camelCaseName,
            '(',
            ...(hasProperties ? ['final @Nullable ', name, ' props'] : []),
            hasProperties && withOptions ? ', ' : '',
            withOptions ? 'final @Nullable Options options' : '',
            ')'
        ], () => {
            this.emitLine([
                'this.analytics.track("',
                naming_1.getRawName(name),
                '", ',
                hasProperties ? 'props.toProperties()' : 'new Properties()',
                withOptions ? ', options' : '',
                ');'
            ]);
        });
    }
    emitAnalyticsWrapper() {
        const className = lodash_1.upperFirst(lodash_1.camelCase(`${this.options.trackingPlan || ''}Analytics`));
        this.emitFileHeader(className, [
            'com.segment.analytics.Analytics',
            'com.segment.analytics.Options',
            'com.segment.analytics.Properties',
            'android.content.Context',
            'androidx.annotation.NonNull',
            'androidx.annotation.Nullable'
        ]);
        this.emitBlock(['public class ', className], () => {
            this.emitLine('private Analytics analytics;');
            this.ensureBlankLine();
            this.emitDescriptionBlock([
                [
                    'Initializes a new ',
                    className,
                    ' client wrapping the provided Segment Analytics client.'
                ],
                '@param analytics {@link Analytics} configured Segment analytics instance',
                '@see <a href="https://segment.com/docs/sources/mobile/android/#getting-started">Android Getting Started</a>'
            ]);
            this.emitBlock(['public ', className, '(final @NonNull Analytics analytics)'], () => {
                this.emitLine('this.analytics = analytics;');
            });
            this.ensureBlankLine();
            this.forEachTopLevel('leading-and-interposing', (t, name) => {
                if (t instanceof quicktype_core_1.ObjectType) {
                    const hasProperties = t.getProperties().size > 0;
                    this.emitAnalyticsEventWrapper(name, hasProperties, false);
                    this.ensureBlankLine();
                    this.emitAnalyticsEventWrapper(name, hasProperties, true);
                }
            });
        });
    }
    emitSourceStructure() {
        super.emitSourceStructure();
        this.emitAnalyticsWrapper();
    }
}
function genJava(events, { package: packageName, trackingPlan }) {
    return __awaiter(this, void 0, void 0, function* () {
        return quicktype_core_1.quicktypeMultiFile({
            lang: new AnalyticsJavaTargetLanguage(packageName, trackingPlan),
            inputData: rules_1.processEventsForQuickType(events)
        });
    });
}
exports.genJava = genJava;
exports.handler = cli_1.getTypedTrackHandler((params, { events }) => __awaiter(this, void 0, void 0, function* () {
    let files;
    if (params.language === 'java') {
        files = yield genJava(events, params);
    }
    else {
        throw new Error(`Invalid language: ${params.language}`);
    }
    // Handle filename naming collisions. Note that many filesystems are case-insensitive,
    // so CheckIn.java === Checkin.java
    // This is a temporary solution, until an upstream PR can be made to QuickType.
    // See: https://quicktype.slack.com/archives/C68E91E8J/p1551486779009600
    const seenFilenames = new Set();
    return Promise.all(lodash_1.map([...files.keys()], (fileName) => {
        if (seenFilenames.has(fileName.toLowerCase())) {
            console.warn(`Multiple events in your Tracking Plan map to the same filename (${fileName}). Consider removing or changing one of these events. If this is a blocker, please open an issue: https://github.com/segmentio/typewriter/issues/new`);
        }
        seenFilenames.add(fileName.toLowerCase());
        return writeFile(`${params.outputPath}/${fileName}`, files.get(fileName).lines.join('\n'));
    }));
}));
//# sourceMappingURL=gen-android.js.map